# 19주차 (2023.04.03 ~ 04.07)

## 04.07 월요일

1. 불러오는 것의 성능보다는 일관된 방법을 선택하는 것이 좋다.

2. 성공했으면 다시 리로딩 하는 것이 좋다. 불필요한 다른 로직을 채용할 필요를 줄이자.
   다만 다른 성능이나 고객의 요구사항 등등 다른 조건이 필요하면 채택을 고려해보자.

3. 진짜로 nodejs로 써서 vue를 할 것이냐.... -> 가자!

4. node.js

5. REPL (Read Eval Print Loop)

6. CLI (Command Line Interface)

7. 렛풀방식

8. js를 위한 모듈 시스템

- nodejs의 가장 강력한 힘은 노드 모듈을 쉽게 만들고 공유할 수 있다는 점이다.
- 라이브러리들이 모인 곳 npm

9. NodeJs의 모듈 시스템

- 스크립트 수준에서 제공하는 모듈이 없다.
- 노드는 es6전에 만들어져서 모듈을 표현하고 싶기에 CommonJS 를 택했다.
- 지금은 두 가지 다 지원하지만 CommonJS 방식이

10. CommonJS 방식으로 고립된 모듈을 구현 방법.

- exports 객체를 통해서 구현.
- 모듈이 허락한 속성을 사용.

19. package.json

- pom.xml 과 비슷한 포지션

20. 분리라는 개념이 들어가면 -> 컴포넌트

- 레이아웃
- 조합형 페이지, 컴포넌트 안의 컴포넌트
- 싸이월드의 배경음악이 쌉가능.

## 04.04 화요일

1. 바벨스크립트 : 변환기 상위 버전을 하위 버전으로 바꿔줄게요.

2. sass : 예전 css 변수화 같은 변환기

3. 프레임워크를 쓰지말고 플랫폼을 최대한 쓰자..

- 프로그램을 다 꼬아버림.
- dom : 바닐라JS
- mvc : angularJs, vue, react, svelte.

3. webpack : 도구들 다 쓰세여. 번역은 내가 함.

- 개발할때 다시 할 때마다, 번들을 계속해서 느림.. -> vite 등장.
- 배포본을 만드는 번들 시스템.
- 최신 js를, 정확히는 모듈 기능이 없었을 때 대신 다 긁어모아서 모듈 시스템처럼 사용하게 해줬던 친구.

- 개발 서버가 필요하다. -> 웹팩은 따로 개발 서버를 두었는데 vite 아 내가 다 가지고있슴~.

4. 쓸만한 페이지만 번들링 해주는 친구 : vite가 등장.

5. 변환기 쓰면 single file component 쓸 수 있음.

6. 원래 한 파일에 두고 쓸 수 있던 것 아니였나?

- 컴포넌트 별로 나눠서 가져갈때도 고립화를 가지고 갈 수 있다.
- 다 패키징해서 번들해주는 친구가 vite (vue에선)

7. 계산기 모듈화.

8. <script> type 중에 importmap 이 있따.


9. vue라는 친구는 이미 importmap을 설정한 상태.

10. 노드js에다가 사용할 변환기를 얹어서 라이브러리

- 변환기가 없을때 라이브러리로만

11. cdn이 뭐지?

- 제이쿼리 : 79%
- cdnjs 에서 받으면 통일도 되고 빠름.
- vue 도 cdn에서받는다

12. <script> 와 <script setup>

## 04.05 수요일

0. git 에서 vue 프로젝 받을때

- 해당 폴더로 경로 설정 후에 npm i 해서 모듈들 설치해줘야함.

1. 변환기가 사용될 수 있는 환경 - node

- 번들링, 패키징 -> 현재 vite 사용 중
- vue 2.0 시절에는 webpack 사용했었음.
- vite 가 dev 서버까지 내포해서 버벅임도 많이 줄었다.
- 확장자를 js대신 vue로
- vue 파일을 통한 장점
- composition 형태로 api들을 사용할 수 있다.

2. url에 따라서 원하는 컴포넌트를 바꿀 수 있어야 한다.

- page 전환 : 라우팅 또는 네비게이션
- vue Router : vue 에서 공식적으로 지원하는 라우팅 라이브러리.
- npm 말고도 yarn이 추가로 나왔는데 속도가 더 났다는 말이 있지만 npm이 아직 많다.
- maven과 gradle 같은 관계

3. router-view

4. 웹페이지는 보통 노출이 되기 위해서 만드는데 vue 라우팅을 통한 웹페이지는 소스가 굉장히 단순하게 나오는데 웹크롤링 같은 봇을 통한 친구들은 소스를 읽어서 노출을 시키기 되는데 이럴때 손해를 보게 되므로 웹 어플리케이션을 만드는데 좀 특화되어 있다고 볼 수 있다.

5. vue-router 를 통한 링크 태그를 <a> 대신 사용해야 할 것 같다.

6. createApp이 컨트롤러를 생성하고 모델을 반환하는 방법을 제시해준다.

7. MVC 패턴을 이해하고, model 기반으로 vue를 사용해서 만들고, 배포할 수 있느냐에 중점을 두고 공부하자.

- vue를 어떻게 만들었는지 까지는 투 머치.

## 04.06 목요일

1. 첫 번째 페이지에서 css 파일을 다 로드해야 하는가?

- 충돌 등등 여러 우려 되는 점이 있으니까 필요한 페이지에서만 로드를 할 수 있겠끔

- 어떻게? 각 vue 파일에 <style> 태그를 넣고 그 안에서 각각의 페이지 스타일 속성 지정 또는 url import 가능.

- 스타일은 <head> 태그 안에 </head>

2. 고립화란 다른 컴포넌트에는 영향이 미치면 안된다.

- 컴포넌트가 포함된 컴포넌트, 라우터 뷰를 통해 끼어 들어가는 자식.
- 포함하고 있는 컴포넌트가 포함된 컴포넌트에게 영향을 줄 수 있다.

3. css 파일이 원 파일이 좋긴 하지만, 나눔으로써 가지는 협업의 가치가 있음.

- css 번들링

  - 장점 :

- 화이트스페이스 (빈 공백)

4. vue에서 style 고립화를 하지 않고 바꾸면 첨에 클라이언트가 파일을 다 받을 때 다 적용시킴으로써 각각의 컴포넌트에 구별해서 적용하려 했던 css가 모든 컴포넌트에 다 적용된다. -> 그렇지 않게 하려면? <style scoped></style>

5. css 압축 유틸 사이트

6. <style scoped></style>

- 너무 많아지면 계속 나머지 스타일들이 반복해서 들어가기 때문에 좋은 방법은 아니다.
- css 집중화를 최대한 잘 해야한다.

7. CORS ERROR

- origin : 서버를 의미.
- 웹 서버에 문서를 요청 (SP, Data)
- page, data를 요청하는 서버가 보통 같다. -> origin이 같다.
- 근데 다르면? -> cross-origin

- https://spring.io/guides/gs/rest-service-cors/
- https://evan-moon.github.io/2020/05/21/about-cors/

- class 마다 해주는 방법.
- 컨트롤러마다 해주는 방법.
- 통짜로 해주는 방법.

8. es6 : 모듈 간의 고립화

- export

  - default

- import

  - as

- importmap : 가져와야 하는 주소가 길거나 하는 문제가 있을 때 별칭을 정해줄 수 있는 맵.

- Dynamic module loading
  - 해당 조건이 만족할 때만 import 할 수 있도록 만들 수 있다.

## 04.07 금요일

1. List.vue 파일에서 fetch 부분

- .then으로 이어지는데 받는 reposnse 이런 것들의 의미.

```vue
<script>
export default {
  data() {
    return {
      list: [{}, {}, {}, {}],
    }
  },
  mounted() {
    fetch('http://localhost:8080/menus')
      .then((response) => response.json())
      .then((list) => (this.list = list))

    // .then 을 하게 되면 위에서 받아온 것을 이어서 계속 받게된다.
    // .then(response => {return response.json();})
    // .then(function(list){
    //   this.list = list;
    //   this.list.push(list[0]);
    // })
  },
}
</script>
```

2. model, dto, vo, domain

- 우리가 쓰고 있는 entity에 대해서...

- 위의 제목에 나열된 4가지와 entity는 비슷한 의미도 있고 다른 의미도 있다.

- 값을 담는다는 것에 대해서 시선이 다르다.

- vo : 제일 하수, 구분하기 싫다는 사람들인데 쓰지 말자.

- model : 가장 entity랑 비슷함. 근데 좀 다르면 model로 따로 패키징.

- entity : db에서 정규화를 하고 나면 업무적으로 정규화된 항목. 테이블 단위가 entity. (동일한 비례.)

- dto : 원격? Stock? 스텁?과 Proxy(가짜 서버)사이..?
  - 로컬인지 원격인지 숨기는 함수 덩어리를 만들어서 소켓인지를 감추고..
  - 줄세우기 데이터 - 시리얼라이제이션 (지금도 사용 중)
  - 컨트롤러가 클라이언트로 보낼 때, 반환할 때 dto
  - 근데 dto랑 entity랑 딱히 다르지 않음.
  - 그렇다면 필요한가? 필요한 부분이 분명히 있음.
  - 변환, 포장을 해서 보낸다면 dto라는 패키지를 만들어서 보내면 된다.

3. 요청하는 페이지를 자세히 적는 것이 일반적이였으나, 요즘은 방법이 다양해졌다.

- 요즘 트렌드는 따로 표시하지 않는 듯하다.
- 경로를 값으로 얻는 방법
- 쿼리로 얻는 방법

4. 쿼리값으로 얻는 방법

5. :to, :src

- v-bind 참고!!!!

6. 랜더링의 순서에 따라서 null 이였던 data값이 적용에 오류가 날수 있다.

- 패치에서 메뉴에 값을 넣어주기 전에, 마운트 이전에 menu가 null 일 당시에 로딩이 되면 오류가 발생한다.

- mounted 의미 : 화면에 보여졌다
- created : 컴포넌트 생성, 데이터를 가져오기 전.

- Uncaught (in promise) TypeError: Cannot read properties of null (reading 'name')

7. vue lifecycle

- created()
- 화면에 데이터가 떠있어야 사용할 수 있는게 많다.

- vue의 생명주기에 대해 더 알아봐야한다.

8.

- document.body.onload
- document.onload
-

9. 디테일페이지의 문제는, 보통 load의 시기에 대한 타이밍에서 발생한다.

10. reactive :

11. 생명주기에 따른 reactive 에 대해서 생각해볼 필요가 있다.

12. v-show

- if는 처리, 그냥 빼버림
- show는 참이지 않으면 숨김. 보이지만 않음.

13. 2차 vue + dom + jpa 하면서 js 복습도 하고

14. 컴포넌트를 뺄 때 원래 양쪽간의 컴포넌트 사이의 고립화를 신경써야 한다.

- 컴포넌트 간의 데이터 전달을 위한 중요한 도구 3가지
  - 속성
  - 메서드
  - 이벤트

15. 컴포넌트 간의 상호작용

- 지금까지는 단순 잘라내기밖에 안했음
- 페치가 너무 많아지면 동기가 힘듦.
- 원격의 모델 - dto라고도 불리고, 뷰에 바인딩할 데이터니 모델이고 애매모호
