# 16주차 정리 (23.03.13 ~ 17)

## 03.13

1. view를 만들어서 findAll 정도만 만들자.

2. JDK 종류

- JavaEE (Enterprise Edtion) : JavaSE + 분산형 어플리케이션 기능
  - 분산형의 최신은 다 웹에 특화되어 있음.
  - 분업화.
  - DI, Transaction 등등.

3.

- 프론트 컨트롤러 : 스프링
- DI : 스프링
- DAO : MyBatis
- 트랜잭션 처리 : 스프링 => Spring AOP

4. 그래서, 트랜잭션 처리가 뭘까?

- 사용자가 원하는 업무라는 지시가 웹의 요청으로 왔을 때(계좌이체)
- 이건 SQL 명령에 없는 그저 업무적인 단위일 뿐.
- 그 단위를 실행하기 위해선 여러 물리적인 명령이 묶여있는 것.
- 그 명령들이 무조건 한 번에 중간에 실패없이 한꺼번에.
- 물리 <-> 논리

5. 트랜잭션이 정상적으로 실행되지 않는 4가지 경우.

- 우리가 처리할 내용은 2가지

- 원자성 : 두 개 이상의 물리적인 명령어가 하나처럼 실행되다가 하나라도 실패되면 원래로 복구되어야 한다.

- 고립화(isolation) : dbms 마다 다름.

- 서버 오퍼레이터가 할 일
  - 연속성 : 디스크에 저장이 안되는 상황도 막아야 한다. (UPS, UPS로 안된다면 로그를 남겨서 전원복구 후 수작업, 화재??)
  - 일관성(Consistency) : 제약 조건

6. AOP란?

- Aspect Oriented(기반) Programing

- Aspect의 의미

  - 사용자의 요구가 아닌 개발자나 운영자가 필요한 요구들?
  - 사용자가 요구한 업무가 아니라 개발자나 운영자가 필요한 업무.
  - 곁다리 업무.

- Concern

  - 로그처리, 보안처리, 트랜잭션처리
  - 필요한 범위가 항상 달라질 수 있다.
  - 반복이 많고, 뺏다 꼇다... 심지어 시간도 짧아야 하고..

- Core Concern (Primary Concern) : 주 관심사.

- AOP를 어디에 적용시켜야 했을까? CoreConcern의 앞과 뒤에.. Core 마다...

- Cross-cutting Concern

  - Core Concern 진행 중에 나와서 Aspect 업무를 한 후에 다시 돌아가는

- Proxy(프록시) : 대리

- AOP는 자바에서도 지원해주고 있다.

- OO처리 란 말은 사용자가 원한게 아님.

7. 한 클래스는 여러 인터페이스를 구현할 수 있다.

8. AOP 지원 플랫폼, 라이브러리다 => 프록시를 만드는 API를 만들어준다는 의미다.

9. 포인트컷? (Joinpoint, Weaving)

- joinpoint : 연결할 수 있는 포인트
- weaving : proxy의 곁다리를 꽂아넣는 작업.

10. Spring에 비해 AspectJ는 잡다한 기능이 너무 많다.

11. 사전이나 사후작업이 필요하고 공통분모들이 많다면 AOP에 대해 더 알아봐야한다.

12. 스프링이 프록시에서 우리가 호출할

13. 스프링 고립성 : 전파 방식, 고립도 지원

- 같은 자원들 두고 동시에 접근하고 있을 때 고립이 필요.

14. 내일 정규화, 고립도 공부

## 03.14

1. erd 피드백

- 개념 설계 부분에서는 확실히 머리 속에서 여태 알던 DB, 테이블 이딴 거 지워버리고<br>
  대상이 무엇을 한다 라는 행위에 집중해야 한다.
- 설정을 수정하는 것보다 애초에 등록이 되어야 개념 설계에서 릴레이션이 생길 수 있고 이미 디폴트 값이 존재하여 있다면 뻗어나가는 것이 아니라 회원 쪽으로 빠져야 한다.
- 커뮤니티 관련을 디벨롭해서 사람들이 계속 서비스를 이용해야 할 매력을 발전시켜야 한다.

2. 정규화

- 보통은 4 정규화 까지. 그 이상은 오바다.
- 중복된 데이터를 가질 수 있는 구조를 중복을 최소화하게 구조화
- 정규화 사이 끼리의 순서는 정해져 있지 않다.

3. 제 1 정규화

- 교과서 : 모든 도메인이 원자값으로 이루어져야 한다.
- 하나의 컬럼에는 같은 값이 들어가면 안된다.

- 도메인 - (유효한 범위)값 -> 컬럼.변수.도메인.
- 순수하게 값이 같아서 하나로 정리하는 게 아니라 가지고 있는 특성이나 의미가 중복이 되냐를 생각.

- 중복을 제거한다.
- 하나의 속성이 하나의 값을 갖도록 한다.

- 최대 몇 번인지 정해져 있지 않다면 잘라내야 한다.

- 데이터베이스 관리 -> 데이터 관리.

4. 제 3 정규화

- 기본 키에 이행적 함수 종속이 되지 않는 것.
- 중간에 걸쳐서 종속이 되는 관계를 끊어내는 것.

- 1 정규화와 비슷.
- 쪼개져서 부모가 나옴.

- one more thing
  - 참조해야 하는 테이블이 없을 때 ->
  - 딱히 함수가 없지만, 중복이 발생 되어 따로 부모를 뽑아내는 경우도 3정규화에서.

5. 제 2 정규화

- 부분 함수 종속성을 없앤다.
- 포린키가 함수. 함수는 (여러 수식을 한 단어나 개념으로 정리)
- 외래키로 참조 할 수 있는 데이터는 없어야 한다.

6. 제 4 정규화

- 다대다 찢어놓기.

7. 데이터와 키의 중복은 다름.

- 데이터가 중복되면 다 바꿔야 함.
- 키는 내용만 바꾸면 됨.

8. 제약 조건

- 값의 조건에 대한 장치들.

9. 이후에

- 트랜잭션의 고립화, 전파.
- 사용자 인증과 권한. -> 스프링 Security
- 구글, 네이버 등등 소셜 로그인.
