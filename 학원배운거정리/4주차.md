# 학원 4주차 일일 오답노트 겸 개인정리

## 2022-12-19

### 1. 구조화를 하지 않은 프로그래밍의 단점

1. 선언한 변수간의 충돌도 잦아지고 엉키면서 변수 선언에서도 어려움을 겪는다.
2. 작성한 데이터들의 용도가 모호해진다.

### 2. 구조화 프로그래밍의 문제점

1. 변수의 데이터 구조를 한번 정의하고 나면 고치기 힘듬.
- 예를 들어 정의된 변수명을 고치게 되면 오류가 여러 곳에서 발생함.
2. 함수를 나누는 기준이 명확하지 않다. => 고립도 하락으로 이어진다.

### 3. 객체지향 프로그래밍
(실세계에서와 같은) 설계 -> 구현

1. 캡슐화

- 그저 함수들을 모아놓은 것이 캡슐화가 아니다. (단순한 클래스 생성이 캡슐화를 의미하지 않음.)
- 데이터 구조와 함수를 하나의 영역에 모아두는 것 => 이것은 곧 행위(Method)를 의미한다.
- 객체지향에서의 캡슐화의 핵심은 **"행위"** 이다.

2. 캡슐화를 통한 개체와 객체 생성

- 개체는 Class를 통해 구현한다.
- Class는 개체의 멤버변수와 Method로 이루어진다.
- Method와 일반 함수의 다른 점
> 일반 함수는 위치가 자유롭고, 단순히 구조화를 목적으로 보통 생성하기 때문에 구별이 쉽지 않다.<br>
> Method의 경우 해당 개체의 "행위"를 목적으로 생성한다.<br>
> 계속 나오는 "행위"는 "이 개체가 무언가를 행동한다" 라는 것이 중요하기에 반복강조한다.

3. 객체의 이모저모

- 객체지향에서는 객체의 속성보다는 행위가 중요하다.
- 객체에는 각각의 해쉬코드가 존재하여 가비지컬렉션에 의해 사용 후 정리된다.
- 실체나 객체, 인스턴스 모두 같은 말이다.

4. 객체의 사용 

- Exam 변수명 = new Exam();
- 캡슐화를 통한 객체 생성 후에는 메소드를 사용하게 되는데
``` java
변수명.input();
```
- 위와 같이 input 이라는 메소드를 사용시 점 앞의 인스턴스를 넘겨 받는다.
- Class 내에서 this는 본인 클래스의 참조변수이다. (쉽게 이해해보자면 본인 개체를 의미한다는 뜻.)
- Method 구현 중에 this를 사용하지 않고 지역변수와 멤버변수가 오버로딩 된다면 우선순위는 지역변수가 먼저이다. 따라서 꼭 멤버변수 값을 사용해야 한다면 this를 써줘야 한다.

5. static
- 함수가 인스턴스의 메소드가 아니라는 의미가 static이다.
- static으로 선언된 함수는 포지셔닝이 자유롭다.
- 따라서 static 함수 내에서는 this도 사용이 불가하다.

6. 생성자
- 객체의 변수를 초기화 시키는 역할.
- 해당 클래스의 이름을 메소드명으로 선언하면 된다.
- Exam 변수명 = new Exam(); 처럼 객체를 생성할 때 마지막 (); 부분이 자바에서 생성자를 자동으로 호출해주는 곳이였다.
- 이것을 내가 원하는 초기화 값으로 설정해고 싶다면 객체클래스에서 선언해주면 된다.
- 생성자의 매개변수를 다르게 지정하여 정의할 수 있다. -> 생성자 오버로딩
- 일종의 메소드라 할 수 있지만 메소드와는 다르다. (썸인가..?)
- 이유 1 : 반드시 클래스명과 동일하게 정의해야 하고
- 이유 2 : 생성자 앞에는 접근제어자만 올 수 있다. (static 노노해)
- 이유 3 : 반환값이 없기때문에 void나 자료형을 작성하지 않는다.
- 한번 짚고 기억에 남겨두는 정도로 알아보자. (많이 쓰게 될거니까)

## 2022-12-20

### 1. 객체지향의 3요소 - 캡슐화, 상속, 다형성

### 2. 캡슐화에 대한 좀 더 정확한 이해

1. 캡슐화의 보편적인 정의 : 데이터 구조와 메소드들을 모아두는 것.
- 하지만 데이터 구조가 없다면? 아니면 데이터 구조만 존재한다면?
- 뉴렉쌤의 정의 : 역할(행위)를 가지고 있는 구성요소

2. '캡슐이 깨진다'의 의미 : 해당 캡슐의 변수나 메소드가 다른 캡슐에 영향을 주거나, 다른 캡슐에 의해 영향을 받게 되는 일.

3. 깨지지 않게 하기 위해선 접근 제어 지시자를 통해 제어해야 한다.
- private : 해당 객체(캡슐)내에서만 접근 가능
- public : 공공연하게~
- protected, default도 있지만 오늘은 여기까지만.

### 3. 오버로드

1. 메소드끼리 같은 이름을 가지게 되면 오버로드라고 한다. (과적)

2. 받는 인자의 차이에 따라 옵션을 가지게 되는데 순정을 기본함수, 옵션을 가진 함수는 오버로드 함수라 지칭한다.

3. 오버로드를 생성하게 되면 두 개 이상의 메소드가 같은 부분을 가지고 있게 되는데 기본 함수에 오버로드 함수를 사용하는 식으로 반복되지 않게 정리해주는 것이 좋다.

4. 생성자도 똑같이 오버로드를 이용할 수 있다.

5. 생성자 오버로드에서 기본 생성자에서 초기화해줄 때 본인 개체를 가르키기 위해서 this를 사용하게 되는데
그 전에는 사용되어서는 안된다.

### 4. 캡슐화를 유지하는 코드 재사용법, 객체 합성 (이 단어도 직역일 가능성이 있을듯.)

1. 캡슐을 데이터구조와 메소드 캡슐로 각각 나누면서도 깨지지 않게 하는 방법.

2. Dependency라는 단어의 뜻 의존, 종속을 그대로 번역하다보니 이해에 어려움이 있다.

3. 데어터구조의 캡슐을 부품이라고 생각하고 이해하도록 하자.

4. 은닉화된 부품에 접근하기 위해서는 게터세터 메소드가 필요하다.

5. 합성엔 두 가지 방법이 있다.
> 1) Composition Has a : 중간 콘솔 메소드 캡슐에서 구성이 완료되어있는 것, 또는 부품이 조립되어 있는 것.
> 2) Association Has a : 부품을 끼어넣어야 되는 것.

## 2022-12-21 (이날 배운건 더 정확한 정리와 이해가 필요)

### 1. Has a 결합
1) 기본적으로 Has a 관계는 클래스의 위아래가 있는 관계이다. 한 클래스가 상대 클래스의 부품 (종속)인 간계.
2) Association, Composition, Aggregation 의 차이는 무엇일까.
- Association : 뒤의 Compositon, Aggregation은 Association의 특별한 케이스 2가지인 경우.
즉 가장 합집합.
- Composition : 컴포지션의 특징은 나머지 클래스 부품들이 존재해야 그걸 가진 클래스가 온전해지는 경우.
- Aggregation : 무조건적인 부품이 아니라 클래스들 서로가 서로의 부품이 되는 경우.
- 위에는 검색해서 알아본 결과.

3) 수업&질문 토대로 정해본 정의
Association : 한 클래스가 부품으로 들어가 있는 상태.
Composition : 부품을 가진 클래스가 객체 생성시에 바로 해당 부품을 이용하는 것.
Aggregation : 부품을 가진 클래스가 자신이 원할 때 해당 부품을 이용하는 것.


### 2. DI (Dependency Injection)
1. 어떻게 관계를 생성하느냐 (조립하느냐)

2. Setter Injection
- set메소드를 생성해서 조립하는 방법
- A,B 클래스가 있다고 했을때 A.set(B); 같은 형식

3. Construction Injection
- 생성자를 통해서 조립하는 방법
- A = new A(B); 같은 형식


### 3. Is a 결합
1. 흔히 말하는 상속.

2. extends 를 사용해서 부모 자식 클래스 관계가 형성된다. (확장)

3. 부모의 틀을 가져와서 자식 클래스에서 사용하는 것이라고 이해하자.

4. 부모 클래스의 private 접근 제한을 갖는 필드 및 메소드는 자식이 물려받을 수 없다.

5. set을 통해 접근할 수 있지만, 은닉성이 사라지는 문제가 생김 => super 사용.

6. super 키워드 : 자식 클래스에서 부모 클래스를 가리킬 때 사용하는 키워드.

7. 부모의 메소드를 자식클래스에서 같은 이름으로 가져다 재생성 하는 것 : 오버라이드.

8. 오버로드 와는 다른 개념. (오버라이드 : 타다, 덮어씌우다. 오버로드 : 쌓는다, 과적)


### 4. 상속 시 참조형식과 호출되는 메소드의 관게
1. newlacExam 클래스가 Exam 클래스에 상속되어 있을 때.

2. Exam exam = new NewlacExam(); 형식으로 생성 가능함.

3. 자식이 부모 메소드를 오버라이딩 했을 경우에 같은 이름의 메소드를 호출할 때 자식 메소드가 먼저 호출된다.

## 2022-12-22 ~ 12-23

### 1. 자바 '웹' 프로그래밍

1. 객체지향은 수납공간을 만드는 것.

2. 위의 객체 결합과 상속을 통해 기반클래스에서 상속받은 확장클래스에서 오버라이딩을 통해 메소드를 재정의할 수 있다는 것을 배운
우리는 이제 프레임워크에 대해 이해하고 배울 수 있다.

3. 인터넷과 WEB은 같은 것이 아니다.
- WEB은 문서 서비스 시스템.
- 인터넷은 로컬네트워크 사이를 이어주는 기술 중 하나. (더 깊게 보면 LAN과 WAN과 인터넷의 상관관계에 대해서도 알 수 있다.)

4. 문서를 보내주는 쪽은 '서버', 받는 쪽은 '클라이언트'

5. 컴퓨터 자체마다 식별할 수 있는 맥(MAC)주소가 존재하고 IP주소가 존재한다.

6. 192.343.23.21 이라는 IP주소에서 192.343.23까지 문서가 전달된 후에 스위치에서 브로드캐스트(방송)을 통해 마지막 21에 위치하는 곳을 찾는다. (방송을 하고 아닌 쪽은 문서를 삭제, 해당인 곳이 맞다고 확인하고 받는 방식)

7. 소켓 : 데이터를 내보내거나 받기위한 창구 역할. IP주소랑 포트, 프로토콜로 정의된다.
- IP주소 : 전 세계 컴퓨터에 부여된 고유의 식별 주소
- 포트 : 네트워크 상에서 통신하기 위해서 호스트 내부적으로 프로세스가 할당받아야 하는 고유한 숫자.
- 프로토콜 : 원래는 외교상의 언어로 의례나 국가간에 약속을 뜻하지만, 통신에서는 어떤 시스템이 다른 시스템과 통신을 원활하게 수용하도록 해주는 통신 규약, 약속.

8. 서버와 클라이언트는 인터넷을 통해 주고 받고있었고 WEB은 그저 문서 서비스 시스템인데 우리는 왜 웹 프로그래밍을 배울까.
- 코드나 DB를 통해 만든 정적인 문서를 웹 서버를 통하여 만들어서 보냄.
- 서블릿 등을 통해 만든 동적인 문서를 웹어플리케이션서버(WAS)를 통하여 보냄. 

9. 웹 서버 와 WAS
- 웹 서버 : 클라이언트로부터 Http 요청을 받아서 정적인 컨텐츠(html, jpeg, css등)을 WAS를 거치치 않고 바로 자원을 제공한다.
- ㄴ 동적인 컨텐츠 제공을 위해 WAS로 요청 전달을 하고 받은 결과를 클라이언트에게 전달하는 역할도 있다.
<br>
- WAS : DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 어플리케이션 서버.
- ㄴ 웹 컨테이너 혹은 서블릿 컨테이너라고도 불린다 => 컨테이너는 JSP,Servlet을 실행시킬 수 있는 소프트웨어를 뜻함.
- ㄴ WAS는 JSP, Servlet 구동 환경을 제공.
- WAS : 웹 서버 + 웹 컨테이너.
- https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html 개념 참고할 때 보기

10. 도메인 네임
- 로컬 네트워크를 아우르는 네트워크 이름, 회사 네트워크의 이름을 사는 것.

11. 네트워크 관련
- 여러 대의 컴퓨터를 연결하기 위해서 처음에는 Bus형을 사용했지만, 한 곳이 쓰면 다른 곳은 사용하지 못하는 병목 현상이 발생하게 되고, 이를 보완하기 위해 Star형을 사용하게 된다. 

