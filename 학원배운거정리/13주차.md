# 13주차 정리 (2023.02.20 ~ 24)

## 02.21

1. 프론트 컨트롤러

- 서블릿 관련 코드 다 모아둠.
- 컨트롤러는 포조가 되고 리퀘스트,리스폰스 같은 서블릿 관련 코드는 다 프론트 컨트롤러에 모아둠.
- @WebServlet("/\*") 해두면 모드 내용이 다 여기로 옴.
- JSPDispatcherServlet 파일로 연습해보고 있음.
- uri 값을 받아서 같게 되면은 포조컨트롤러에서 리턴한 주소 값

2. 리플렉션

- 코드의 정보를 다 꺼내서 사용할 수 있음.

- 라이브러리를 만드는 사람들 이외에는 사용할 일이 많지 않지만 어떤 식으로 이용하는지는 알아야 한다.

```java
Class.forName("com.newlecture.web....");

method.invoke(controller, 3, 4);
// this 지역, 매개변수 값들.
```

3. 사용자가 입력한 값을 프론트 컨트롤러를 통해서 리플렉션을 통해 정리해서 포조코드에 넣어주기

## 02-22

1. MVC 패턴

- Front 컨트롤러도 라이브러리 (Reflect?)
- Cotroller 에서 나온 Service 와 Dao 도 라이브러리 (IOC)
- Dao (JDBC 반복되는 코드를 라이브러리로 => MyBatis, JPA+HB)
- Transcation (AOP)
- Security

  > 인증을 컨트롤러에서 계속 확인하다보면 힘들기 때문에 앞단에서 따로 => 이것도 라이브러리 (Filter)

- 백엔드
  > SSR
  > API (CSR)
- API를 이용한 CSR이 프론트단이라 오해하고 백단이 아니라 생각하는데 아니다.
- SSR은 저물어가는 태양이 아닐까.
- SSR 1차
- CSR 2차

  > Vue.js
  >
  > > - Node.js
  > > - DOM
  > > - ES6
  > > - ??? (더 있음.)

  2. Front 컨트롤러

  - 스터럭치(?)가 유명했는데 사라짐.
  - 라이브러리는 내가 편하게 쓰는 방식일 뿐. 흐름과 패턴을 신경쓰자.

  3. 이클립스 마켓플레이스에서 보는 스프링 툴들은 스프링 자체가 아니라 스프링 라이브러리를 위한 에디터 같은 툴들.

4. maven repo => Spring Web MVC

5. classnotfound,uncomfortable

6. buildtool(빌드툴) 이용해서 스프링 라이브러리 받기

7. MAVEN

- 프로젝트 빌드 과정

  > 프로젝트 생성- 라이브러리 설정 - 코드 작업 - 컴파일 - 테스트 - 패키지 만들기 - 배포 - 레포팅

- ERP : 자원이라건 다 관리하는 프로그램.
- 이클립스는 빌드툴보다 더 큰 IDE.
  > 빌드툴은 IDE가진 도구 중 하나일 뿐.
- 메이븐은 이클립스만을 위한 빌드 도구들이 아니라 범용 빌드 도구.
- 메이븐 프로젝으로 설정해놓으면, IDE를 가리지 않을 수 있음.

- 최근 IDE에 프로젝트 관리와 관련되어 포함되어 있는 전문화된 도구들

  > - Maven
  > - Gradle : 메이븐에 비해 최근에 나왔지만 아직 생태계가 메이븐만큼 아님.
  > - Git , CVS
  > - JUnit

- 이클립스가 제공하지 않는 메이븐만의 기능

  > 라이브러리 설정 : 라이브러리 관리와 의존성 체크 (이 기능이 가장 핵심.)

- mvn archetype:generate -DgroupId=com.newlecture -DartifactId=javaprj -DarchetypeArtifactId=maven-archetype-quickstart

- Maven 자바 프로젝트 생성
- 아키타입 아티팩트아이디에 대한 타입?

- mvn compile
- mvn test
- mvn package : 배포 파일을 실행해 볼 수 있음.
- mvn 하위 명령어들이 뭘까요

- Build Lifecycle

  > validate, compile, test, package, verify, install, deploy

- 절차에서 사용자가 바꿔 낄 수 있는 부분이 있다 할때 라이프 사이클이란 단어가 언급된다.
  <br> 없다면? 라이프사이클 자체가 언급되지 않음. 언급될 이유가 없음.
- packging 한 결과 종류를 정할 수 있음. (jar, war 등등)
- 단계별 실행을 담당하는 플러그인들 : 내가 원하는 버전으로 바꿔 낄 수 있다.

- Phase - Plug-in - Goal
- Class 내의 메소드 들이 있는 것처럼 플러그인에 여러 Goal들이 있음.

- 이클립스에서 메이븐 플젝 열기
- pom.xml 있어야 됨. (이게 뭘까)

- dependency가 중요함.

  > 태그 만으로 라이브러리가 받아진다

- plugin 추가 방법

  > - 직접 플로그인 태그로 쓰기
  > - overview를 통해서 쓰기
  > - 프로퍼티에 넣어두면 한번은 메이븐 업데이트를 해줘야 반응한다.

- 원격저장소 -> 디펜던시 -> 로컬에 없으면 -> 다운로드, 있으면 참조.
- 단점 : 오류로 인해 라이브러리를 잘못받으면 모든 플젝이 오류.
- 지웠어도 프로젝트 실행하면 자동으로 받아옴.

- 메이븐 프로젝트는 업데이트를 자주 해줘야함. 뭐가 잘 안되면 이걸 안했을 가능성이 농후함.

- 라이브러리즈 : java, maven, server

- 범용성, 신뢰성

8. 스프링

- 디스펙쳐 클래스를 객체화, 메모리에 올려주어야 함.
- 맵핑 정보를 심어놓아야 함.
- 라이브러리들을 쓰려면 다 설정과 객체화가 다 필요하다보니 기본 설정하다가 힘들어함.

9. 스프링 부트 기반의 자바 웹 프로그래밍

- Spring Boot

  > Web App <br>
  > Spring Di, Transaction / MVC ... <br>
  > Servlet / JSP <br>
  > WAS(Tomcat)

- 스프링부트 소개 페이지 내용
  > 자바프로그램이라 생각해도 됨.<br>
  > 디펜던시 스타터 라는 이름으로 <br>
  > 자동 컨피규어

## 02.23

1. public, static 폴더 홈 디렉토리 역할. webapp 도 같이

2. view단을 jsp 로 쓴다면 webapp

3. 과거에 리소스 파일을 public으로 뒀었지만 조용히 static으로 변경되었는데 과거 호환성도 있어야 하기 때문에 public, static, webapp이 다 홈 디렉토리가 된다.

4. static : css,img 기타 등등
5. webapp : jsp 파일, 사용자가 업로드한 파일을 두는 곳.
6. templates : thymeleaf 파일
7. public은 원래 안쓰는 것. 퍼블리싱을 위한 작업폴더가 필요하니 이 폴더를 사용하겠다.

8. 순서가 있기에 충돌이 나지 않음.
   static > public > webapps

9. 프론트 컨트롤러에 완전히 서블릿을 밀어내서 완전한 포조컨트롤러들을 만들어보자.

10. 함수명과 상관없이 어노테이션 해놓으면 실행된다.

11. url에 클래스가 아니라 함수가 연결되어 있음. <br>

12. 함수명은 url명과 맞춰서, class명은 폴더명처럼

13. @RestController 안써두면 스프링이 안읽음.

14. 스프링이 객체화 해주면서 변수명이 겹치게 되면 오류가 발생한다.

15.

```java
// 이걸 안써두면 스프링이 안읽음.
@RestController
// 반복되는 상위 주소들은 이렇게 맵핑 주소 적어서 축약시킬 수 있다.
@RequestMapping("/menu")
```

16. 서버 코드 바뀌면 재시작해주는 프로그램.
    플젝 선택 => spring => stater

- dev tools 해주면 바뀌면 재시작해줌.

17. jsp 뷰단이 사용자로 부터 요청이 직접적으로 들어가면 안된다.
    <br>
    전에 했던 것처럼 WEB-INF폴더 만들어서 넣어두기.

18. 처리할 수 없는 jsp 는 다운로드 시키게 한다.

19. 스프링에서 서서히 jsp 지원이 빠지게 되면서 template 쪽에서도 jsp 제스퍼 기능이 없어지니까 메이븐에서 디펜더시로 추가해주자.

20. Rest : 웹에서 데이터를 전송하고 처리하는 방법을 정의하는 인터페이스

21. @RestController : 사용자에게 데이터만 전송

22. 그냥 @Controller는 view를 찾는 역할

23. State Transfer

24. REST 가 생겨난 이유 : 발달함에 따라 서버의 부담이 심해지고 (데이타를 소비하는 계층이 많아짐.)

25. REST 원칙 중..

- 서버 클라이언트 둘로 나누어서 한 쪽은 공급, 한 쪽은 소비만 하도록 구분해야한다.
- 서버는 데이터 제공만. (중요)
- 상태가 유지가 될 필요없이 사용될 수 있어야 한다. 등등

- 레스트 풀의 형태를 제공하고 있다.

26. SSR (서바 사이드 렌더링) : 서버에서 뷰단에서 데이터까지 다 렌더링 해서 클라이언트로 보내주는 거.

27. 다음 시간은 스프링의 프론트와 DI기능 모델을 만들어서 뷰에서 활용하기.
- 출력을 다뤘으니 더 추가적인 방법
- 입력받는 방법
- DI
